# jpa

#### 关于jpa事务数据自动更新

在事务下，通过JPA从数据库查询得到实体，对实体进行修改，在事务完成后会自动根据该实体对数据库进行更新。

**对象的状态**

1. 临时(新建)状态：对象被创建时的状态，数据库里面没有与之对应的记录！也就是没有保存到数据库之前的状态。
2. 持久(托管)状态：处于session的管理中，并且数据库里面存在与之对应的记录。
3. 游离(脱管)状态：对象不处于session的管理中，但是数据库里面存在与之对应的记录。
4. 删除状态：数据库中没有，Session缓存中没有。

**自动更新原因**

当实体类处于托管状态时，往这个对象里set新的值，就会自动更新到数据库表中。

通过JPA查询的到实体类对象，添加到缓存中，在对缓存中的数据进行一系列操作之后，在提交事务时，会调用flush()方法，更新数据库。

**避免自动更新**

1. 在事务提交前调用refresh() **不推荐**

refresh() 就是对缓存中的数据更新，就是当实体类对象和数据库表中数据不同，就会将数据库中的数据更新到缓存。数据由数据库到缓存。

2. 将对象状态改为游离态。

evict(obj)：将某个对象清出缓存session

clear()：将所有对象清楚缓存(劳师动众)

3. 避免直接修改查询出的实体类对象，转换成vo修改。

#### JpaSpecificationExecutor

使用JpaSpecificationExecutor进行动态查询，首先需要在dao接口中继承该接口。

```java
public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User>
```

可以看到该接口内有5个方法

```java
// JpaSpecificationExecutor 接口
T findOne(Specification<T> spec);
List<T> findAll(Specification<T> spec);
// 通过条件查找所有，分页
Page<T> findAll(Specification<T> spec, Pageable pageable);
// 通过条件查找所有，排序
List<T> findAll(Specification<T> spec, Sort sort);
long count(Specification<T> spec);
```

每个方法都至少需要传入`Specification`对象，`Specification`也是个接口

```java
// Specification 接口
// 该接口内，只要实现了这个方法就行，该方法就是你的查询条件
// 参数：root 查询的根对象；query 顶层查询对象，自定义查询条件(一般不用)；cb 查询语句构造器
Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder cb);
```

所以要通过`JpaSpecificationExecutor`使用它的方法，就要实现`Specification`接口(提供泛型：查询的对象类型) ----> 实现`toPredicate`方法(构造查询条件)

**自定义findOne单个条件查询**

```java
@Test
public void testSpec() {

	Specification<User> spec = new Specification<User>() {
		@Override
		public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
			// 取需要查询的对象属性
			Path<Object> userName = root.get("userName");
			// 进行精准的匹配，
			// 第一个参数：需要比较的属性（path对象）,第二个参数：当前需要比较的取值
            // 查找名字为 张三 的用户
			Predicate predicate = cb.equal(userName, "张三");
			return predicate;
		}
	};
	User user = userRepository.findOne(spec);
	System.out.println(user);
}
```

**自定义findOne多条件查询**

只需多添加几个`CriteriaBuilder`

```java
@Test
public void testSpec() {

	Specification<User> spec = new Specification<User>() {
		@Override
		public Predicate toPredicate(Root<Customer> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
			// 取需要查询的对象属性
			Path<Object> userName = root.get("userName");
            Path<Object> age = root.get("age");
			// 构造第一个查询条件的精确匹配
			Predicate p1 = cb.equal(userName, "张三");
            // 构造第二个查询条件的精确匹配
            Predicate p2 = cb.equal(age, 20);
            // 将多个查询条件组合到一起
			Predicate and = cb.and(p1, p2);
			// cb.or();//以或的形式拼接多个查询条件
			return and;
		}
	};
	User user = userRepository.findOne(spec);
	System.out.println(user);
}
```

前面的精准匹配可以直接用`Path`对象，进行比较即可，但是

> 模糊查询`like`不能直接用它，需要指定比较的参数类型。 **好像不准确**

```java
// CriteriaBuilder 接口
// equal 可以直接传入对象即可，不用管类型，第一个参数
Predicate equal(Expression<?> x, Object y);
// 而 like 则必须要传入指定类型，String
Predicate like(Expression<String> x, String pattern);
// 类似的还有 gt(大于) 等等， 传入Number的子类
Predicate gt(Expression<? extends Number> x, Number y);
```

例如：

```java
Predicate like = cb.like(userName.as(String.class), "张%");
```

**排序，分页**

排序和分页只要创建各自的对象，再在`findAll`方法中传入对象就行了。

例如：

```java
// 排序
Sort sort = new Sort(Sort.Direction.DESC,"custId");
userRepository.findAll(spec, sort);

// 分页, 也可以带有排序
Pageable pageable = PageRequest.of(0,2,Sort.Direction.DESC,"id");
userRepository.findAll(spec, pageable);
```

